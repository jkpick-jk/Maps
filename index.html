#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>

MCUFRIEND_kbv tft;

#define C_BG     0x0000
#define C_ROAD   0x7BEF
#define C_WATER  0x001F
#define C_BUILD  0xFFFF
#define C_BRIDGE 0xA145
#define C_PLAYER 0x001F   // Blue
#define C_OTHER  0xF800   // Red

int pixelSize = 8;
int gridW = 60;
int gridH = 40;

int roadY[60];
int riverX[40];

int carX = 0;
int carY = 0;

// Incoming cars
struct OtherCar {
  int x;
  int y;
};
OtherCar others[3]; // 3 other cars

float slope = 0;
float targetSlope = 0;

// Fake coordinates for simulation
float lat = 14.0;
float lon = 121.0;

void drawBlock(int x, int y, uint16_t color) {
  tft.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize, color);
}

void drawCircleBlock(int x, int y, uint16_t color) {
  int cx = x * pixelSize + pixelSize / 2;
  int cy = y * pixelSize + pixelSize / 2;
  tft.fillCircle(cx, cy, pixelSize / 2, color);
}

bool isRiver(int x, int y) {
  return abs(x - riverX[y]) <= 2;
}

void generateRiver() {
  int rx = random(10, gridW - 10);
  float riverSlope = 0;

  for (int y = 0; y < gridH; y++) {
    if (random(0, 10) == 0) riverSlope = random(-10, 11) / 20.0;
    rx += riverSlope;
    if (rx < 3) rx = 3;
    if (rx > gridW - 4) rx = gridW - 4;
    riverX[y] = rx;

    for (int w = -2; w <= 2; w++)
      drawBlock(rx + w, y, C_WATER);
  }
}

void generateRoad() {
  int y = gridH / 2;
  slope = 0;
  targetSlope = 0;

  for (int x = 0; x < gridW; x++) {
    if (random(0, 15) == 0) targetSlope = random(-10, 11) / 20.0;
    slope += (targetSlope - slope) * 0.1;
    y += slope;
    if (y < 6) y = 6;
    if (y > gridH - 6) y = gridH - 6;

    roadY[x] = y;

    for (int w = -2; w <= 2; w++) {
      int drawY = y + w;
      if (drawY >= 0 && drawY < gridH) {
        if (isRiver(x, drawY))
          drawBlock(x, drawY, C_BRIDGE);
        else
          drawBlock(x, drawY, C_ROAD);
      }
    }
  }
}

void generateNeighborhoods() {
  for (int n = 0; n < 3; n++) {
    int startX = random(5, gridW - 15);
    int startY = random(5, gridH - 15);

    for (int x = 0; x < 10; x += 2)
      for (int y = 0; y < 10; y += 2) {
        int gx = startX + x;
        int gy = startY + y;
        if (!isRiver(gx, gy) && abs(gy - roadY[gx]) > 4) {
          drawBlock(gx, gy, C_BUILD);
          drawBlock(gx + 1, gy, C_BUILD);
          drawBlock(gx, gy + 1, C_BUILD);
          drawBlock(gx + 1, gy + 1, C_BUILD);
        }
      }
  }
}

void generateIncomingCars() {
  for (int i = 0; i < 3; i++) {
    int spawnX = random(0, gridW / 2);
    int spawnY = roadY[spawnX];
    others[i].x = spawnX;
    others[i].y = spawnY;
  }
}

void generateMap() {
  tft.fillScreen(C_BG);

  generateRiver();
  generateRoad();
  generateNeighborhoods();
  generateIncomingCars();

  carX = 0;
  carY = roadY[0];
  lat = 14.0;
  lon = 121.0;
}

void drawCoordinates() {
  tft.setCursor(2, 2);
  tft.setTextColor(C_BUILD);
  tft.setTextSize(1);
  tft.print("Lat: "); tft.print(lat, 3);
  tft.print("  Lon: "); tft.println(lon, 3);
}

void setup() {
  uint16_t ID = tft.readID();
  tft.begin(ID);
  tft.setRotation(1);
  randomSeed(analogRead(0));

  generateMap();
}

void loop() {

  // erase previous player
  drawCircleBlock(carX, carY, isRiver(carX, carY) ? C_BRIDGE : C_ROAD);

  // erase previous other cars
  for (int i = 0; i < 3; i++) {
    drawCircleBlock(others[i].x, others[i].y, isRiver(others[i].x, others[i].y) ? C_BRIDGE : C_ROAD);
  }

  // Move player
  carX++;
  if (carX >= gridW) {
    generateMap();
    delay(200);
    return;
  }
  carY = roadY[carX];

  // Move other cars (simple random speed)
  for (int i = 0; i < 3; i++) {
    others[i].x += 1 + random(0, 2);
    if (others[i].x >= gridW) others[i].x = 0;
    others[i].y = roadY[others[i].x];
  }

  // draw player
  drawCircleBlock(carX, carY, C_PLAYER);

  // draw others
  for (int i = 0; i < 3; i++) {
    drawCircleBlock(others[i].x, others[i].y, C_OTHER);
  }

  // fake coordinates increment
  lat += 0.0001;
  lon += 0.0001;
  drawCoordinates();

  delay(50);
}
